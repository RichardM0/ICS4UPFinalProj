
import java.awt.event.*;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.RenderingHints;
import java.awt.Image;
import javax.swing.JPanel;
import javax.swing.Timer;
import javax.swing.ImageIcon;
import java.util.ArrayList;
import java.util.Random;
public class GravityPanel extends JPanel implements ActionListener
{
   /*
    * Instance and Static variables for OrbiterPanel class
    * Includes timer, speed variables, motion variables, and arraylist for orbiters, 
    */
   private int delay = 10;
   private static final double G = 6.67430e-11;
   protected Timer timer;
   private ArrayList<Orbiter> orbiters = new ArrayList<Orbiter>();
   private ArrayList<Meteor> meteors = new ArrayList<Meteor>();
   private GravityPointer gp = new GravityPointer(90,90);
   private int orbitDist = 2*gp.getRadius()+10;
   private double angle = Math.PI/256;
   private boolean isStopped = true;
   private boolean dragged = false;
   public static String speed = "low";
   private String movement = "linear";
   private ImageIcon gifIcon;
   /*
    * constructor for objects of OrbiterPanel
    * create an "original" orbiter
    * Start a timer to keep refreshing screen
    */
   public GravityPanel()
   {
      timer = new Timer(delay, this);
      timer.start();
      gifIcon = new ImageIcon("./images/blackHoleGif.gif");
   }
   /*
    * actionPerformed method
    * repaints orbiter to screen constantly
    */
   public void actionPerformed(ActionEvent e)
   {
       repaint();
   }
   /*
    * paintComponent method
    * Paints every orbiter to the screen
    * Checks every orbiter's positions and boundaries to change dX, dY
    * Move the orbiter if stop button was not pressed
    */
   public void paintComponent( Graphics g )
   {
       super.paintComponent( g );
       
       /*Graphics2D g2d = (Graphics2D) g.create();
       g2d.drawImage(gifIcon.getImage(), (int)gp.getX(), (int)gp.getY(), 2*gp.getRadius(), 2*gp.getRadius(), this);
       g2d.dispose();*/
       g.fillOval((int)gp.getX(), (int)gp.getY(), gp.getRadius()*2, gp.getRadius()*2);
       meteorCollision();
       for(Orbiter b : orbiters){
           g.setColor(b.getColor());
           if(b.getX()>this.getWidth() - b.getRadius() || b.getX()<b.getRadius()){
               b.setX(b.getX()>this.getWidth() - b.getRadius() ? this.getWidth() - b.getRadius() : b.getRadius());
               b.setDx(-b.getDx());
           }
           if(b.getY()>this.getHeight() - b.getRadius() || b.getY()<0 + b.getRadius()){
               b.setY(b.getY()>this.getHeight() - b.getRadius() ? this.getHeight() - b.getRadius() : b.getRadius());
               b.setDy(-b.getDy());
           }
           if(!isStopped && !dragged){
               b.move((int)gp.getX()+gp.getRadius() - 10, (int)gp.getY()+gp.getRadius() - 10, orbitDist);
               //b.setX(gp.getX()-b.getDistX());
               //b.setY(gp.getY()-b.getDistY());
           }
           g.fillOval((int)b.getX(), (int)b.getY(), b.getRadius()*2, b.getRadius()*2);
       }
       g.setColor(Color.blue);
       for(Meteor b : meteors){
           if(!isStopped){
               b.move();
           }
           g.fillOval((int)b.getX(), (int)b.getY(), b.getRadius()*2, b.getRadius()*2);
       }
       if(!isStopped){
           gp.move();
           attraction();
           gpTurn();
           gpQuadrant();
       }
   }
   public void dragGP(int mX, int mY){
       int lowY = (int)gp.getY();
       int upY = (int)gp.getY()+2*gp.getRadius();
       int dude = mY-2*gp.getRadius();
       System.out.println(lowY + ", " + dude + ", " + upY);
       if((mX>gp.getX() && mX<gp.getX()+2*gp.getRadius()) && (mY-2*gp.getRadius()>gp.getY() && mY-2*gp.getRadius()<gp.getY()+2*gp.getRadius())){
           gp.setX(mX-gp.getRadius());
           gp.setY(mY-2*gp.getRadius());
       }
   }
   public void reset(){
       orbiters.clear();
       meteors.clear();
       gp.setMass(1e14);
       gp.setRadius(35);
       orbitDist = 90;
   }
   public void orbiterReset(){
       for(Orbiter b : orbiters){
           b.setDx(3.0);
           b.setDy(3.0);
       }
       for(Meteor b : meteors){
           b.setDx(3.0);
           b.setDy(3.0);
       }
   }
   public void attraction(){
       for(Meteor b : meteors){
           double dx = (gp.getX()+gp.getRadius())-(b.getX()+b.getRadius());
           double dy = (gp.getY()+gp.getRadius())-(b.getY()+b.getRadius());
           double distance = Math.sqrt(dx*dx + dy*dy);
           double fx = 0;
           double fy = 0;

           if (distance > b.getRadius() + gp.getRadius()) { 
               double force = (G * b.getMass() * gp.getMass()) / (distance * distance);
               fx += force * (dx / distance);
               fy += force * (dy / distance);
           }
           b.updateVel(fx, fy);
       }
   }
   public void meteorCollision(){
       try{
           for(Meteor b : meteors){
               double mX = b.getX();
               double mY = b.getY();
               if((mX>gp.getX() && mX<gp.getX()+2*gp.getRadius()) && (mY>gp.getY() && mY<gp.getY()+2*gp.getRadius())){
                   meteors.remove(b);
                   if(gp.getRadius()>60 || gp.getMass() > 5e14){
                       continue;
                   }
                   gp.setRadius(gp.getRadius() + 1);
                   gp.setMass(gp.getMass() + 1e13);
                   orbitDist += 1;
               }
           }
       }catch(Exception e){;}
   }
   /*
    * setSpeed method
    * Adjusts speed to low, medium, or high
    * Scales dX, dY, circular/sinusoidal curving speed z
    * Keeps track of current speed selected using String s
    */
   public void setSpeed(double x, double y, int z, String s){
       speed = s;
       for(Orbiter b : orbiters){
           if(b.getDx()<0){
               b.setDx(-x);
           }
           else if(b.getDx()>0){
               b.setDx(x);
           }
           if(b.getDy()<0){
               b.setDy(-y);
           }
           else if(b.getDy()>0){
               b.setDy(y);
           }
       }
   }
   /*
    * setStopped method and setStart method
    * setStopped stops motion
    * setStart starts motion
    */
   public void setStopped(){
       isStopped = true;
   }
   public void setStart(){
       isStopped = false;
   }
   public void addMeteor(){
       if(isStopped){
           return;
       }
       Random rand = new Random();
       int width = this.getWidth();
       int height = this.getHeight();
       int x = 30 + rand.nextInt(30 + 3*width/4);
       int y = 30 + rand.nextInt(30 + 3*height/4);
       while((x>gp.getX() - 2*gp.getRadius() && x<gp.getX() + 2*gp.getRadius()) || y>gp.getY() - 2*gp.getRadius() && y<gp.getY() + 2*gp.getRadius()){
           x = 30 + rand.nextInt(30 + 3*width/4);
           y = 30 + rand.nextInt(30 + 3*height/4);
       }
       Meteor m = new Meteor(x,y,20);
       meteors.add(m);
   }
   public boolean inOrbiter(int x, int y){
       for(Orbiter b: orbiters){
           if((x>b.getX() && x<b.getX()+2*b.getRadius()) && (y>b.getY() && y<b.getY()+2*b.getRadius())){
               return true;
           }
       }
       return false;
   }
   /*
    * addOrbiter method
    * Adds orbiter to the OrbiterPanel
    * Uses java.util.Random to randomize position and Color
    * Sets speed of orbiter according to the selected speed
    * add orbiter to arrayList orbiters
    */
   public void addOrbiter(){
        Random rand = new Random();
        /*int width = this.getWidth();
        int height = this.getHeight();
        int lowX = (int)gp.getX() - 10 - rand.nextInt(60);
        int upperX = (int)gp.getX() - 10 + rand.nextInt(100);
        int lowY = (int)gp.getY() - 10 - rand.nextInt(60);
        int upperY = (int)gp.getY() - 10 + rand.nextInt(10);
        int x = rand.nextBoolean() ? lowX : upperX;
        int y = rand.nextBoolean() ? lowY : upperY;
        
        while(inOrbiter(x,y)){
            x = rand.nextBoolean() ? lowX : upperX;
            y = rand.nextBoolean() ? lowY : upperY;
        }*/
        if(orbiters.size() > 16 || isStopped){
            return;
        }
        int x = 0;
        int y = 0;
        Orbiter b = new Orbiter(x, y, 10, (int)gp.getX() - x, (int)gp.getY() - y);
        if(speed.equals("low")){
            b.setDx(3.0);
        }
        else if(speed.equals("medium")){
            b.setDx(6.0);
        }
        else if(speed.equals("high")){
            b.setDx(9.0);
        }
        b.setColor(Color.red);
        orbiters.add(b);
   }
   /*
    * setColor method
    * Changes color of every orbiter
    * Go through every orbiter in orbiters arrayList to change color
    */
   public void setColor(Color c){
        for(Orbiter b : orbiters){
            b.setColor(c);
        }
   }
   public void gpTurn(){
        int width = this.getWidth();
        int height = this.getHeight();
        if(gp.getMoving() == 1 && gp.getX() >= width-orbitDist-2*gp.getRadius()){
            gp.setMoving(2);
        }
        else if(gp.getMoving() == 2 && gp.getY() >= height-orbitDist-2*gp.getRadius()){
            gp.setMoving(3);
        }
        else if(gp.getMoving() == 3 && gp.getX() <= orbitDist){
            gp.setMoving(4);
        }
        else if(gp.getMoving() == 4 && gp.getY() <= orbitDist){
            gp.setMoving(1);
        }
   }
   public void gpQuadrant(){
        int width = this.getWidth();
        int height = this.getHeight();
        if((gp.getX()>0 && gp.getX()<width/2) && (gp.getY()>0 && gp.getY()<height/2)){
            gp.setQuadrant(1);
        }
        else if((gp.getX()>width/2 && gp.getX()<width) && (gp.getY()>0 && gp.getY()<height/2)){
            gp.setQuadrant(2);
        }
        else if((gp.getX()>0 && gp.getX()<width/2) && (gp.getY()>height/2 && gp.getY()<height)){
            gp.setQuadrant(3);
        }
        else if((gp.getX()>width/2 && gp.getX()<width) && (gp.getY()>height/2 && gp.getY()<height)){
            gp.setQuadrant(4);
        }
   }
   public void boundQuadrant()
   {
       int width = this.getWidth();
       int height = this.getHeight();
       for(Orbiter b : orbiters){
           if(b.getX() > gp.getX() + width/4 - b.getRadius() || b.getX() < Math.max(b.getRadius(), gp.getX() - width/4 + b.getRadius())){
                b.setX(b.getX() > gp.getX() + width/4 - b.getRadius() ? gp.getX() + width/4 - b.getRadius() : Math.max(b.getRadius(), gp.getX() - width/4 + b.getRadius()));
           }
           if(b.getY() > gp.getY() + height/4 - b.getRadius() || b.getY() < Math.max(b.getRadius(), gp.getY() - height/4 + b.getRadius())){
                b.setY(b.getY() > gp.getY() + height/4 - b.getRadius() ? gp.getY() + height/4 - b.getRadius() : Math.max(b.getRadius(), gp.getY() - height/4 + b.getRadius()));
           }
       }
   }
   
}
